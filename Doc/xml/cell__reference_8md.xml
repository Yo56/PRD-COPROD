<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="fr">
  <compounddef id="cell__reference_8md" kind="file" language="Markdown">
    <compoundname>cell_reference.md</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">#<sp/>cell_reference</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```static<sp/>std::pair&lt;std::string,<sp/>row_t&gt;<sp/>xlnt::cell_reference::split_reference(const<sp/>std::string<sp/>&amp;reference_string)```</highlight></codeline>
<codeline><highlight class="normal">Splits<sp/>a<sp/>coordinate<sp/>string<sp/>like<sp/>&quot;A1&quot;<sp/>into<sp/>an<sp/>equivalent<sp/>pair<sp/>like<sp/>{&quot;A&quot;,<sp/>1}.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```static<sp/>std::pair&lt;std::string,<sp/>row_t&gt;<sp/>xlnt::cell_reference::split_reference(const<sp/>std::string<sp/>&amp;reference_string,<sp/>bool<sp/>&amp;absolute_column,<sp/>bool<sp/>&amp;absolute_row)```</highlight></codeline>
<codeline><highlight class="normal">Splits<sp/>a<sp/>coordinate<sp/>string<sp/>like<sp/>&quot;A1&quot;<sp/>into<sp/>an<sp/>equivalent<sp/>pair<sp/>like<sp/>{&quot;A&quot;,<sp/>1}.<sp/>Reference<sp/>parameters<sp/>absolute_column<sp/>and<sp/>absolute_row<sp/>will<sp/>be<sp/>set<sp/>to<sp/>true<sp/>if<sp/>column<sp/>part<sp/>or<sp/>row<sp/>part<sp/>are<sp/>prefixed<sp/>by<sp/>a<sp/>dollar-sign<sp/>indicating<sp/>they<sp/>are<sp/>absolute,<sp/>otherwise<sp/>false.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```xlnt::cell_reference::cell_reference()```</highlight></codeline>
<codeline><highlight class="normal">Default<sp/>constructor<sp/>makes<sp/>a<sp/>reference<sp/>to<sp/>the<sp/>top-left-most<sp/>cell,<sp/>&quot;A1&quot;.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```xlnt::cell_reference::cell_reference(const<sp/>char<sp/>*reference_string)```</highlight></codeline>
<codeline><highlight class="normal">Constructs<sp/>a<sp/>cell_reference<sp/>from<sp/>a<sp/>string<sp/>reprenting<sp/>a<sp/>cell<sp/>coordinate<sp/>(e.g.<sp/>$B14).</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```xlnt::cell_reference::cell_reference(const<sp/>std::string<sp/>&amp;reference_string)```</highlight></codeline>
<codeline><highlight class="normal">Constructs<sp/>a<sp/>cell_reference<sp/>from<sp/>a<sp/>string<sp/>reprenting<sp/>a<sp/>cell<sp/>coordinate<sp/>(e.g.<sp/>$B14).</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```xlnt::cell_reference::cell_reference(column_t<sp/>column,<sp/>row_t<sp/>row)```</highlight></codeline>
<codeline><highlight class="normal">Constructs<sp/>a<sp/>cell_reference<sp/>from<sp/>a<sp/>1-indexed<sp/>column<sp/>index<sp/>and<sp/>row<sp/>index.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```cell_reference&amp;<sp/>xlnt::cell_reference::make_absolute(bool<sp/>absolute_column=true,<sp/>bool<sp/>absolute_row=true)```</highlight></codeline>
<codeline><highlight class="normal">Converts<sp/>a<sp/>coordinate<sp/>to<sp/>an<sp/>absolute<sp/>coordinate<sp/>string<sp/>(e.g.<sp/>B12<sp/>-&gt;<sp/>$B$12)<sp/>Defaulting<sp/>to<sp/>true,<sp/>absolute_column<sp/>and<sp/>absolute_row<sp/>can<sp/>optionally<sp/>control<sp/>whether<sp/>the<sp/>resulting<sp/>cell_reference<sp/>has<sp/>an<sp/>absolute<sp/>column<sp/>(e.g.<sp/>B12<sp/>-&gt;<sp/>$B12)<sp/>and<sp/>absolute<sp/>row<sp/>(e.g.<sp/>B12<sp/>-&gt;<sp/>B$12)<sp/>respectively.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```bool<sp/>xlnt::cell_reference::column_absolute()<sp/>const```</highlight></codeline>
<codeline><highlight class="normal">Returns<sp/>true<sp/>if<sp/>the<sp/>reference<sp/>refers<sp/>to<sp/>an<sp/>absolute<sp/>column,<sp/>otherwise<sp/>false.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```void<sp/>xlnt::cell_reference::column_absolute(bool<sp/>absolute_column)```</highlight></codeline>
<codeline><highlight class="normal">Makes<sp/>this<sp/>reference<sp/>have<sp/>an<sp/>absolute<sp/>column<sp/>if<sp/>absolute_column<sp/>is<sp/>true,<sp/>otherwise<sp/>not<sp/>absolute.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```bool<sp/>xlnt::cell_reference::row_absolute()<sp/>const```</highlight></codeline>
<codeline><highlight class="normal">Returns<sp/>true<sp/>if<sp/>the<sp/>reference<sp/>refers<sp/>to<sp/>an<sp/>absolute<sp/>row,<sp/>otherwise<sp/>false.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```void<sp/>xlnt::cell_reference::row_absolute(bool<sp/>absolute_row)```</highlight></codeline>
<codeline><highlight class="normal">Makes<sp/>this<sp/>reference<sp/>have<sp/>an<sp/>absolute<sp/>row<sp/>if<sp/>absolute_row<sp/>is<sp/>true,<sp/>otherwise<sp/>not<sp/>absolute.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```column_t<sp/>xlnt::cell_reference::column()<sp/>const```</highlight></codeline>
<codeline><highlight class="normal">Returns<sp/>a<sp/>string<sp/>that<sp/>identifies<sp/>the<sp/>column<sp/>of<sp/>this<sp/>reference<sp/>(e.g.<sp/>second<sp/>column<sp/>from<sp/>left<sp/>is<sp/>&quot;B&quot;)</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```void<sp/>xlnt::cell_reference::column(const<sp/>std::string<sp/>&amp;column_string)```</highlight></codeline>
<codeline><highlight class="normal">Sets<sp/>the<sp/>column<sp/>of<sp/>this<sp/>reference<sp/>from<sp/>a<sp/>string<sp/>that<sp/>identifies<sp/>a<sp/>particular<sp/>column.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```column_t::index_t<sp/>xlnt::cell_reference::column_index()<sp/>const```</highlight></codeline>
<codeline><highlight class="normal">Returns<sp/>a<sp/>1-indexed<sp/>numeric<sp/>index<sp/>of<sp/>the<sp/>column<sp/>of<sp/>this<sp/>reference.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```void<sp/>xlnt::cell_reference::column_index(column_t<sp/>column)```</highlight></codeline>
<codeline><highlight class="normal">Sets<sp/>the<sp/>column<sp/>of<sp/>this<sp/>reference<sp/>from<sp/>a<sp/>1-indexed<sp/>number<sp/>that<sp/>identifies<sp/>a<sp/>particular<sp/>column.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```row_t<sp/>xlnt::cell_reference::row()<sp/>const```</highlight></codeline>
<codeline><highlight class="normal">Returns<sp/>a<sp/>1-indexed<sp/>numeric<sp/>index<sp/>of<sp/>the<sp/>row<sp/>of<sp/>this<sp/>reference.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```void<sp/>xlnt::cell_reference::row(row_t<sp/>row)```</highlight></codeline>
<codeline><highlight class="normal">Sets<sp/>the<sp/>row<sp/>of<sp/>this<sp/>reference<sp/>from<sp/>a<sp/>1-indexed<sp/>number<sp/>that<sp/>identifies<sp/>a<sp/>particular<sp/>row.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```cell_reference<sp/>xlnt::cell_reference::make_offset(int<sp/>column_offset,<sp/>int<sp/>row_offset)<sp/>const```</highlight></codeline>
<codeline><highlight class="normal">Returns<sp/>a<sp/>cell_reference<sp/>offset<sp/>from<sp/>this<sp/>cell_reference<sp/>by<sp/>the<sp/>number<sp/>of<sp/>columns<sp/>and<sp/>rows<sp/>specified<sp/>by<sp/>the<sp/>parameters.<sp/>A<sp/>negative<sp/>value<sp/>for<sp/>column_offset<sp/>or<sp/>row_offset<sp/>results<sp/>in<sp/>a<sp/>reference<sp/>above<sp/>or<sp/>left<sp/>of<sp/>this<sp/>cell_reference,<sp/>respectively.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```std::string<sp/>xlnt::cell_reference::to_string()<sp/>const```</highlight></codeline>
<codeline><highlight class="normal">Returns<sp/>a<sp/>string<sp/>like<sp/>&quot;A1&quot;<sp/>for<sp/>cell_reference(1,<sp/>1).</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```range_reference<sp/>xlnt::cell_reference::to_range()<sp/>const```</highlight></codeline>
<codeline><highlight class="normal">Returns<sp/>a<sp/>1x1<sp/>range_reference<sp/>containing<sp/>only<sp/>this<sp/>cell_reference.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```range_reference<sp/>xlnt::cell_reference::operator,(const<sp/>cell_reference<sp/>&amp;other)<sp/>const```</highlight></codeline>
<codeline><highlight class="normal">I&apos;ve<sp/>always<sp/>wanted<sp/>to<sp/>overload<sp/>the<sp/>comma<sp/>operator.<sp/>cell_reference(&quot;A&quot;,<sp/>1),<sp/>cell_reference(&quot;B&quot;,<sp/>1)<sp/>will<sp/>return<sp/>range_reference(cell_reference(&quot;A&quot;,<sp/>1),<sp/>cell_reference(&quot;B&quot;,<sp/>1))</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```bool<sp/>xlnt::cell_reference::operator==(const<sp/>cell_reference<sp/>&amp;comparand)<sp/>const```</highlight></codeline>
<codeline><highlight class="normal">Returns<sp/>true<sp/>if<sp/>this<sp/>reference<sp/>is<sp/>identical<sp/>to<sp/>comparand<sp/>including<sp/>in<sp/>absoluteness<sp/>of<sp/>column<sp/>and<sp/>row.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```bool<sp/>xlnt::cell_reference::operator==(const<sp/>std::string<sp/>&amp;reference_string)<sp/>const```</highlight></codeline>
<codeline><highlight class="normal">Constructs<sp/>a<sp/>cell_reference<sp/>from<sp/>reference_string<sp/>and<sp/>return<sp/>the<sp/>result<sp/>of<sp/>their<sp/>comparison.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```bool<sp/>xlnt::cell_reference::operator==(const<sp/>char<sp/>*reference_string)<sp/>const```</highlight></codeline>
<codeline><highlight class="normal">Constructs<sp/>a<sp/>cell_reference<sp/>from<sp/>reference_string<sp/>and<sp/>return<sp/>the<sp/>result<sp/>of<sp/>their<sp/>comparison.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```bool<sp/>xlnt::cell_reference::operator!=(const<sp/>cell_reference<sp/>&amp;comparand)<sp/>const```</highlight></codeline>
<codeline><highlight class="normal">Returns<sp/>true<sp/>if<sp/>this<sp/>reference<sp/>is<sp/>not<sp/>identical<sp/>to<sp/>comparand<sp/>including<sp/>in<sp/>absoluteness<sp/>of<sp/>column<sp/>and<sp/>row.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```bool<sp/>xlnt::cell_reference::operator!=(const<sp/>std::string<sp/>&amp;reference_string)<sp/>const```</highlight></codeline>
<codeline><highlight class="normal">Constructs<sp/>a<sp/>cell_reference<sp/>from<sp/>reference_string<sp/>and<sp/>return<sp/>the<sp/>result<sp/>of<sp/>their<sp/>comparison.</highlight></codeline>
<codeline><highlight class="normal">##<sp/>```bool<sp/>xlnt::cell_reference::operator!=(const<sp/>char<sp/>*reference_string)<sp/>const```</highlight></codeline>
<codeline><highlight class="normal">Constructs<sp/>a<sp/>cell_reference<sp/>from<sp/>reference_string<sp/>and<sp/>return<sp/>the<sp/>result<sp/>of<sp/>their<sp/>comparison.</highlight></codeline>
    </programlisting>
    <location file="C:/Users/nouet/Documents/Cours/5A/Dev PRD/PrdCoprod/PrdCoprod/libs/xlnt-1.5.0/docs/api/cell_reference.md"/>
  </compounddef>
</doxygen>
