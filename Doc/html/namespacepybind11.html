<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PR&amp;D COPROD: Référence de l&#39;espace de nommage pybind11</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PR&amp;D COPROD
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">Outil d&#39;aide a la planification des operations de maintenance preventive et corrective - Polytech Tours - Yohan Nouet</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Recherche','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Recherche');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Espaces de nommage</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Définitions de type</a> &#124;
<a href="#enum-members">Énumérations</a> &#124;
<a href="#func-members">Fonctions</a>  </div>
  <div class="headertitle">
<div class="title">Référence de l'espace de nommage pybind11</div>  </div>
</div><!--header-->
<div class="contents">

<p>glibc defines I as a macro which breaks things, e.g., boost template names  
<a href="namespacepybind11.html#details">Plus de détails...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Espaces de nommage</h2></td></tr>
<tr class="memitem:namespacepybind11_1_1____main____"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11_1_1____main____.html">__main__</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepybind11_1_1__version"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11_1_1__version.html">_version</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepybind11_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepybind11_1_1literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11_1_1literals.html">literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1is__method.html">is_method</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for methods.  <a href="structpybind11_1_1is__method.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1is__operator.html">is_operator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for operators.  <a href="structpybind11_1_1is__operator.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1scope.html">scope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for parent scope.  <a href="structpybind11_1_1scope.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1doc.html">doc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for documentation.  <a href="structpybind11_1_1doc.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1name.html">name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for function names.  <a href="structpybind11_1_1name.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1sibling.html">sibling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation indicating that a function is an overload associated with a given "sibling".  <a href="structpybind11_1_1sibling.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1base.html">base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation indicating that a class derives from another given type.  <a href="structpybind11_1_1base.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1keep__alive.html">keep_alive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep patient alive while nurse lives.  <a href="structpybind11_1_1keep__alive.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1multiple__inheritance.html">multiple_inheritance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation indicating that a class is involved in a multiple inheritance relationship.  <a href="structpybind11_1_1multiple__inheritance.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1dynamic__attr.html">dynamic_attr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation which enables dynamic attributes, i.e. adds <code>__dict__</code> to a class.  <a href="structpybind11_1_1dynamic__attr.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1buffer__protocol.html">buffer_protocol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation which enables the buffer protocol for a type.  <a href="structpybind11_1_1buffer__protocol.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1metaclass.html">metaclass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation which requests that a special metaclass is created for a type.  <a href="structpybind11_1_1metaclass.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1arithmetic.html">arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation to mark enums as an arithmetic type.  <a href="structpybind11_1_1arithmetic.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1call__guard.html">call_guard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1call__guard_3_4.html">call_guard&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1call__guard_3_01_t_01_4.html">call_guard&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1call__guard_3_01_t_00_01_ts_8_8_8_01_4.html">call_guard&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1buffer__info.html">buffer_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information record describing a Python buffer object.  <a href="structpybind11_1_1buffer__info.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1arg.html">arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1arg__v.html">arg_v</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1error__already__set.html">error_already_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch and hold an error which was already set in Python.  <a href="classpybind11_1_1error__already__set.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1builtin__exception.html">builtin_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ bindings of builtin Python exceptions.  <a href="classpybind11_1_1builtin__exception.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1stop__iteration.html">stop_iteration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1index__error.html">index_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1key__error.html">key_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1value__error.html">value_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1type__error.html">type_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1cast__error.html">cast_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1reference__cast__error.html">reference_cast_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when <a class="el" href="namespacepybind11.html#ade1f8946c805279f41d7f6eed0d4f07d">pybind11::cast</a> or handle::call fail due to a type casting error.  <a href="classpybind11_1_1reference__cast__error.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor.html">format_descriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01_t_00_01detail_1_1enable__if__t_3_01std_1_1is__arithmet544813167d407bc8aa26457640f1dd29.html">format_descriptor&lt; T, detail::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1error__scope.html">error_scope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII wrapper that temporarily clears any Python error state.  <a href="structpybind11_1_1error__scope.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1nodelete.html">nodelete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy destructor wrapper that can be used to expose classes with a private destructor.  <a href="structpybind11_1_1nodelete.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1overload__cast.html">overload_cast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01std_1_1complex_3_01_t_01_4_00_01detail_1_1enable__if__tb4d0725a4aff8e133ba8b72ef20abea4.html">format_descriptor&lt; std::complex&lt; T &gt;, detail::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1scoped__interpreter.html">scoped_interpreter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1dtype.html">dtype</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1array.html">array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1array__t.html">array_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01_t_00_01detail_1_1enable__if__t_3_01detail_1_1is__pod__2541c7600b5fc9094049e2495342ba9e.html">format_descriptor&lt; T, detail::enable_if_t&lt; detail::is_pod_struct&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01char_0f_n_0e_4.html">format_descriptor&lt; char[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01std_1_1array_3_01char_00_01_n_01_4_01_4.html">format_descriptor&lt; std::array&lt; char, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01_t_00_01detail_1_1enable__if__t_3_01std_1_1is__enum_3_01_t_01_4_1_1value_01_4_01_4.html">format_descriptor&lt; T, detail::enable_if_t&lt; std::is_enum&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01_t_00_01detail_1_1enable__if__t_3_01detail_1_1array__indf15e44072e0df87924bd69ebdc6a173.html">format_descriptor&lt; T, detail::enable_if_t&lt; detail::array_info&lt; T &gt;::is_array &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1options.html">options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1cpp__function.html">cpp_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an arbitrary C++ function/method/lambda function/.. into a callable Python object.  <a href="classpybind11_1_1cpp__function.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1module.html">module</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for Python extension modules.  <a href="classpybind11_1_1module.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1class__.html">class_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1enum__.html">enum_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds C++ enumerations and enumeration classes to Python.  <a href="classpybind11_1_1enum__.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1exception.html">exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1gil__scoped__acquire.html">gil_scoped_acquire</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1gil__scoped__release.html">gil_scoped_release</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1handle.html">handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1object.html">object</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1iterator.html">iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1iterable.html">iterable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1str.html">str</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1bytes.html">bytes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1none.html">none</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1bool__.html">bool_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1int__.html">int_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1float__.html">float_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1weakref.html">weakref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1slice.html">slice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1capsule.html">capsule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1tuple.html">tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1dict.html">dict</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1sequence.html">sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1list.html">list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1args.html">args</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1kwargs.html">kwargs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1set.html">set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1function.html">function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1buffer.html">buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1memoryview.html">memoryview</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Définitions de type</h2></td></tr>
<tr class="memitem:aa14f653ec1b63f58b3013ef9d6ac9422"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:aa14f653ec1b63f58b3013ef9d6ac9422"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#aa14f653ec1b63f58b3013ef9d6ac9422">arg_t</a> = <a class="el" href="structpybind11_1_1arg__v.html">arg_v</a></td></tr>
<tr class="memdesc:aa14f653ec1b63f58b3013ef9d6ac9422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for backward compatibility &ndash; to be removed in version 2.0.  <a href="namespacepybind11.html#aa14f653ec1b63f58b3013ef9d6ac9422">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa14f653ec1b63f58b3013ef9d6ac9422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e3d317b399f8925c3b9f1980018481"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a51e3d317b399f8925c3b9f1980018481">ssize_t</a> = Py_ssize_t</td></tr>
<tr class="separator:a51e3d317b399f8925c3b9f1980018481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74292751b6fc8fe14d7c6772ae2fd0fc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a74292751b6fc8fe14d7c6772ae2fd0fc">size_t</a> = std::size_t</td></tr>
<tr class="separator:a74292751b6fc8fe14d7c6772ae2fd0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1dc06329bd734b9632f108e2006e25"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a9c1dc06329bd734b9632f108e2006e25">EigenDStride</a> = Eigen::Stride&lt; Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a9c1dc06329bd734b9632f108e2006e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23484f7bb5fa23363d338c66c71dc6a8"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a23484f7bb5fa23363d338c66c71dc6a8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a23484f7bb5fa23363d338c66c71dc6a8">EigenDRef</a> = Eigen::Ref&lt; MatrixType, 0, <a class="el" href="namespacepybind11.html#a9c1dc06329bd734b9632f108e2006e25">EigenDStride</a> &gt;</td></tr>
<tr class="separator:a23484f7bb5fa23363d338c66c71dc6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f353deb5dca5ef06dd63358f9a9bb20"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a6f353deb5dca5ef06dd63358f9a9bb20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a6f353deb5dca5ef06dd63358f9a9bb20">EigenDMap</a> = Eigen::Map&lt; MatrixType, 0, <a class="el" href="namespacepybind11.html#a9c1dc06329bd734b9632f108e2006e25">EigenDStride</a> &gt;</td></tr>
<tr class="separator:a6f353deb5dca5ef06dd63358f9a9bb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Énumérations</h2></td></tr>
<tr class="memitem:a5f83e7a05cee9068927633ac47dbe69c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca2bd9c0ed00116be1258e0cc66617d7c8">automatic</a> = 0
, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca1c1628c22d69b3b9bac4b5c3674852e3">automatic_reference</a>
, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca5dc4bb19391b04351f49572019c628c0">take_ownership</a>
, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca12cba3ee81cf4a793796a51b6327c678">copy</a>
, <br />
&#160;&#160;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca3734a903022249b3010be1897042568e">move</a>
, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69cab8af13ea9c8fe890c9979a1fa8dbde22">reference</a>
, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69caa39bc0596cb125c1605a78fbd287df7f">reference_internal</a>
<br />
 }</td></tr>
<tr class="memdesc:a5f83e7a05cee9068927633ac47dbe69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approach used to cast a previously unknown C++ instance into a Python object.  <a href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">Plus de détails...</a><br /></td></tr>
<tr class="separator:a5f83e7a05cee9068927633ac47dbe69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a5898f9a083026531bc5d435f715ea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715ea">eval_mode</a> { <a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715eaa86e05cca1e5516b3ff4014f9af34aaff">eval_expr</a>
, <a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715eaa9cf39a293befe652b5046b1e7cf9fe58">eval_single_statement</a>
, <a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715eaa22b140993f208620cf25bba6e0d5590b">eval_statements</a>
 }</td></tr>
<tr class="separator:a08a5898f9a083026531bc5d435f715ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Fonctions</h2></td></tr>
<tr class="memitem:ade1f8946c805279f41d7f6eed0d4f07d"><td class="memTemplParams" colspan="2">template&lt;typename T , detail::enable_if_t&lt;!detail::is_pyobject&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ade1f8946c805279f41d7f6eed0d4f07d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#ade1f8946c805279f41d7f6eed0d4f07d">cast</a> (const <a class="el" href="classpybind11_1_1handle.html">handle</a> &amp;<a class="el" href="classpybind11_1_1handle.html">handle</a>)</td></tr>
<tr class="separator:ade1f8946c805279f41d7f6eed0d4f07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f21f6281dddbba982c721e93d1f60e"><td class="memTemplParams" colspan="2">template&lt;typename T , detail::enable_if_t&lt;!detail::is_pyobject&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a87f21f6281dddbba982c721e93d1f60e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a87f21f6281dddbba982c721e93d1f60e">cast</a> (const T &amp;value, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> policy=<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca1c1628c22d69b3b9bac4b5c3674852e3">return_value_policy::automatic_reference</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> parent=<a class="el" href="classpybind11_1_1handle.html">handle</a>())</td></tr>
<tr class="separator:a87f21f6281dddbba982c721e93d1f60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cadb7f665dad17868aa4cd045f3b017"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3cadb7f665dad17868aa4cd045f3b017"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacepybind11_1_1detail.html#a492fb1fcf079a5bc67248b852bc73619">detail::enable_if_t</a>&lt;!<a class="el" href="namespacepybind11_1_1detail.html#a9b95d0bea18a9cb7599182d1f32a7f6a">detail::move_never</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a3cadb7f665dad17868aa4cd045f3b017">move</a> (<a class="el" href="classpybind11_1_1object.html">object</a> &amp;&amp;obj)</td></tr>
<tr class="separator:a3cadb7f665dad17868aa4cd045f3b017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9d391ba89e4dbc85bc088c637a454b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb9d391ba89e4dbc85bc088c637a454b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacepybind11_1_1detail.html#a492fb1fcf079a5bc67248b852bc73619">detail::enable_if_t</a>&lt; <a class="el" href="structpybind11_1_1detail_1_1move__always.html">detail::move_always</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#adb9d391ba89e4dbc85bc088c637a454b">cast</a> (<a class="el" href="classpybind11_1_1object.html">object</a> &amp;&amp;<a class="el" href="classpybind11_1_1object.html">object</a>)</td></tr>
<tr class="separator:adb9d391ba89e4dbc85bc088c637a454b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c29751349cfc3a1b5e8b4765c23e55"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37c29751349cfc3a1b5e8b4765c23e55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacepybind11_1_1detail.html#a492fb1fcf079a5bc67248b852bc73619">detail::enable_if_t</a>&lt; <a class="el" href="structpybind11_1_1detail_1_1move__if__unreferenced.html">detail::move_if_unreferenced</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a37c29751349cfc3a1b5e8b4765c23e55">cast</a> (<a class="el" href="classpybind11_1_1object.html">object</a> &amp;&amp;<a class="el" href="classpybind11_1_1object.html">object</a>)</td></tr>
<tr class="separator:a37c29751349cfc3a1b5e8b4765c23e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d1d141b22c8733a7212bc74d89cbf8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23d1d141b22c8733a7212bc74d89cbf8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacepybind11_1_1detail.html#a492fb1fcf079a5bc67248b852bc73619">detail::enable_if_t</a>&lt; <a class="el" href="namespacepybind11_1_1detail.html#a9b95d0bea18a9cb7599182d1f32a7f6a">detail::move_never</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a23d1d141b22c8733a7212bc74d89cbf8">cast</a> (<a class="el" href="classpybind11_1_1object.html">object</a> &amp;&amp;<a class="el" href="classpybind11_1_1object.html">object</a>)</td></tr>
<tr class="separator:a23d1d141b22c8733a7212bc74d89cbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829aea796e8a24212b310db43534c1b7"><td class="memTemplParams" colspan="2">template&lt;return_value_policy policy = return_value_policy::automatic_reference, typename... Args&gt; </td></tr>
<tr class="memitem:a829aea796e8a24212b310db43534c1b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1tuple.html">tuple</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a829aea796e8a24212b310db43534c1b7">make_tuple</a> (Args &amp;&amp;... args_)</td></tr>
<tr class="separator:a829aea796e8a24212b310db43534c1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46240bdb807f80caa6e104591878d5c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpybind11_1_1arg.html">arg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11_1_1literals.html#ad46240bdb807f80caa6e104591878d5c">operator&quot;&quot;_a</a> (const char *<a class="el" href="structpybind11_1_1name.html">name</a>, <a class="el" href="namespacepybind11.html#a74292751b6fc8fe14d7c6772ae2fd0fc">size_t</a>)</td></tr>
<tr class="separator:ad46240bdb807f80caa6e104591878d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f875b57085d18e33b68e3c666facf8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a43f875b57085d18e33b68e3c666facf8">__attribute__</a> ((noinline)) void *set_shared_data(const std</td></tr>
<tr class="memdesc:a43f875b57085d18e33b68e3c666facf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the shared data that can be later recovered by <code>get_shared_data()</code>.  <a href="namespacepybind11.html#a43f875b57085d18e33b68e3c666facf8">Plus de détails...</a><br /></td></tr>
<tr class="separator:a43f875b57085d18e33b68e3c666facf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa297ec4bf4b85dc134d56708fbfcc850"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa297ec4bf4b85dc134d56708fbfcc850"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#aa297ec4bf4b85dc134d56708fbfcc850">get_or_create_shared_data</a> (const std::string &amp;<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:aa297ec4bf4b85dc134d56708fbfcc850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a37202a545a53e60d9722b5712b9171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a4a37202a545a53e60d9722b5712b9171">initialize_interpreter</a> (bool init_signal_handlers=true)</td></tr>
<tr class="separator:a4a37202a545a53e60d9722b5712b9171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f49a19c03be57ee8ff8427a5f30dc20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a2f49a19c03be57ee8ff8427a5f30dc20">finalize_interpreter</a> ()</td></tr>
<tr class="separator:a2f49a19c03be57ee8ff8427a5f30dc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26f489829ee95049a3cbf473d3c50bc"><td class="memTemplParams" colspan="2">template&lt;eval_mode mode = eval_expr&gt; </td></tr>
<tr class="memitem:ae26f489829ee95049a3cbf473d3c50bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#ae26f489829ee95049a3cbf473d3c50bc">eval</a> (<a class="el" href="classpybind11_1_1str.html">str</a> expr, <a class="el" href="classpybind11_1_1object.html">object</a> global=<a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>(), <a class="el" href="classpybind11_1_1object.html">object</a> local=<a class="el" href="classpybind11_1_1object.html">object</a>())</td></tr>
<tr class="separator:ae26f489829ee95049a3cbf473d3c50bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b1a96dad971e6c0edd9b796cc57880"><td class="memTemplParams" colspan="2">template&lt;eval_mode mode = eval_expr, size_t N&gt; </td></tr>
<tr class="memitem:a56b1a96dad971e6c0edd9b796cc57880"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a56b1a96dad971e6c0edd9b796cc57880">eval</a> (const char(&amp;s)[N], <a class="el" href="classpybind11_1_1object.html">object</a> global=<a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>(), <a class="el" href="classpybind11_1_1object.html">object</a> local=<a class="el" href="classpybind11_1_1object.html">object</a>())</td></tr>
<tr class="separator:a56b1a96dad971e6c0edd9b796cc57880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ca1928aef1b51fa07d8720ce75fdf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#ad3ca1928aef1b51fa07d8720ce75fdf7">exec</a> (<a class="el" href="classpybind11_1_1str.html">str</a> expr, <a class="el" href="classpybind11_1_1object.html">object</a> global=<a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>(), <a class="el" href="classpybind11_1_1object.html">object</a> local=<a class="el" href="classpybind11_1_1object.html">object</a>())</td></tr>
<tr class="separator:ad3ca1928aef1b51fa07d8720ce75fdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38838be20e46edfdb3dbc03f176d7bc"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ae38838be20e46edfdb3dbc03f176d7bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#ae38838be20e46edfdb3dbc03f176d7bc">exec</a> (const char(&amp;s)[N], <a class="el" href="classpybind11_1_1object.html">object</a> global=<a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>(), <a class="el" href="classpybind11_1_1object.html">object</a> local=<a class="el" href="classpybind11_1_1object.html">object</a>())</td></tr>
<tr class="separator:ae38838be20e46edfdb3dbc03f176d7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3958ed51fe6e4bf962b04e32d01c242"><td class="memTemplParams" colspan="2">template&lt;eval_mode mode = eval_statements&gt; </td></tr>
<tr class="memitem:ab3958ed51fe6e4bf962b04e32d01c242"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#ab3958ed51fe6e4bf962b04e32d01c242">eval_file</a> (<a class="el" href="classpybind11_1_1str.html">str</a> fname, <a class="el" href="classpybind11_1_1object.html">object</a> global=<a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>(), <a class="el" href="classpybind11_1_1object.html">object</a> local=<a class="el" href="classpybind11_1_1object.html">object</a>())</td></tr>
<tr class="separator:ab3958ed51fe6e4bf962b04e32d01c242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccb3d918a6c83f0ed93b7aae5e3dd77"><td class="memTemplParams" colspan="2">template&lt;typename Return , typename... Args&gt; </td></tr>
<tr class="memitem:a4ccb3d918a6c83f0ed93b7aae5e3dd77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpybind11_1_1detail_1_1vectorize__helper.html">detail::vectorize_helper</a>&lt; Return(*)(Args...), Return, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a4ccb3d918a6c83f0ed93b7aae5e3dd77">vectorize</a> (Return(*f)(Args ...))</td></tr>
<tr class="separator:a4ccb3d918a6c83f0ed93b7aae5e3dd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9b99aeffa23dc8596bc5ab46bdec99"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename FuncType  = typename detail::remove_class&lt;decltype(&amp;detail::remove_reference_t&lt;Func&gt;::operator())&gt;::type&gt; </td></tr>
<tr class="memitem:a5a9b99aeffa23dc8596bc5ab46bdec99"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a5a9b99aeffa23dc8596bc5ab46bdec99">vectorize</a> (Func &amp;&amp;f) -&gt; decltype(<a class="el" href="namespacepybind11_1_1detail.html#a25c49715d64fc799eef5cfa04f20d119">detail::vectorize_extractor</a>(std::forward&lt; Func &gt;(f),(FuncType *) nullptr))</td></tr>
<tr class="separator:a5a9b99aeffa23dc8596bc5ab46bdec99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb3c0b9044e0b0d3e8fc0324f485acf"><td class="memTemplParams" colspan="2">template&lt;typename Return , typename Class , typename... Args, typename Helper  = detail::vectorize_helper&lt;decltype(std::mem_fn(std::declval&lt;Return (Class::*)(Args...)&gt;())), Return, Class *, Args...&gt;&gt; </td></tr>
<tr class="memitem:a1cb3c0b9044e0b0d3e8fc0324f485acf"><td class="memTemplItemLeft" align="right" valign="top">Helper&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a1cb3c0b9044e0b0d3e8fc0324f485acf">vectorize</a> (Return(Class::*f)(Args...))</td></tr>
<tr class="separator:a1cb3c0b9044e0b0d3e8fc0324f485acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4397f2663d6784bd53630fc5a23c02a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1dict.html">dict</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a> ()</td></tr>
<tr class="separator:gaf4397f2663d6784bd53630fc5a23c02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80923cbfeaa7668191f479b40a94957e"><td class="memTemplParams" colspan="2">template&lt;typename , typename F &gt; </td></tr>
<tr class="memitem:a80923cbfeaa7668191f479b40a94957e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a80923cbfeaa7668191f479b40a94957e">method_adaptor</a> (F &amp;&amp;f) -&gt; decltype(std::forward&lt; F &gt;(f))</td></tr>
<tr class="separator:a80923cbfeaa7668191f479b40a94957e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb36fd4bbf6d949769e083dc9bdf7426"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename Return , typename Class , typename... Args&gt; </td></tr>
<tr class="memitem:aeb36fd4bbf6d949769e083dc9bdf7426"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#aeb36fd4bbf6d949769e083dc9bdf7426">method_adaptor</a> (Return(Class::*pmf)(Args...)) -&gt; Return(Derived::*)(Args...)</td></tr>
<tr class="separator:aeb36fd4bbf6d949769e083dc9bdf7426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67231190432080a41b98fd771c5d3dff"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a67231190432080a41b98fd771c5d3dff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpybind11_1_1detail_1_1init.html">detail::init</a>&lt; Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a67231190432080a41b98fd771c5d3dff">init</a> ()</td></tr>
<tr class="separator:a67231190432080a41b98fd771c5d3dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d1d3fd106f97b8e8fbc0047c8b924f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a92d1d3fd106f97b8e8fbc0047c8b924f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpybind11_1_1detail_1_1init__alias.html">detail::init_alias</a>&lt; Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a92d1d3fd106f97b8e8fbc0047c8b924f">init_alias</a> ()</td></tr>
<tr class="separator:a92d1d3fd106f97b8e8fbc0047c8b924f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97330a2a87d0653768770751b057c5e"><td class="memTemplParams" colspan="2">template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename ValueType  = decltype(*std::declval&lt;Iterator&gt;()), typename... Extra&gt; </td></tr>
<tr class="memitem:ac97330a2a87d0653768770751b057c5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#ac97330a2a87d0653768770751b057c5e">make_iterator</a> (Iterator first, Sentinel last, Extra &amp;&amp;... extra)</td></tr>
<tr class="memdesc:ac97330a2a87d0653768770751b057c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a python iterator from a first and past-the-end C++ InputIterator.  <a href="namespacepybind11.html#ac97330a2a87d0653768770751b057c5e">Plus de détails...</a><br /></td></tr>
<tr class="separator:ac97330a2a87d0653768770751b057c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9720b33862b4fbd9345c2bf2a0e407f7"><td class="memTemplParams" colspan="2">template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename KeyType  = decltype((*std::declval&lt;Iterator&gt;()).first), typename... Extra&gt; </td></tr>
<tr class="memitem:a9720b33862b4fbd9345c2bf2a0e407f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a9720b33862b4fbd9345c2bf2a0e407f7">make_key_iterator</a> (Iterator first, Sentinel last, Extra &amp;&amp;... extra)</td></tr>
<tr class="separator:a9720b33862b4fbd9345c2bf2a0e407f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7e251f8927c3f839ec9beff8662a4c"><td class="memTemplParams" colspan="2">template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </td></tr>
<tr class="memitem:abc7e251f8927c3f839ec9beff8662a4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#abc7e251f8927c3f839ec9beff8662a4c">make_iterator</a> (Type &amp;value, Extra &amp;&amp;... extra)</td></tr>
<tr class="separator:abc7e251f8927c3f839ec9beff8662a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451a8f82d09d763f5400dead333116ee"><td class="memTemplParams" colspan="2">template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </td></tr>
<tr class="memitem:a451a8f82d09d763f5400dead333116ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a451a8f82d09d763f5400dead333116ee">make_key_iterator</a> (Type &amp;value, Extra &amp;&amp;... extra)</td></tr>
<tr class="separator:a451a8f82d09d763f5400dead333116ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d4074b855542774c3fbdd75697d48c"><td class="memTemplParams" colspan="2">template&lt;typename InputType , typename OutputType &gt; </td></tr>
<tr class="memitem:aa3d4074b855542774c3fbdd75697d48c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#aa3d4074b855542774c3fbdd75697d48c">implicitly_convertible</a> ()</td></tr>
<tr class="separator:aa3d4074b855542774c3fbdd75697d48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4353c0dbefd359b04ebef9e47a0eb359"><td class="memTemplParams" colspan="2">template&lt;typename ExceptionTranslator &gt; </td></tr>
<tr class="memitem:a4353c0dbefd359b04ebef9e47a0eb359"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a4353c0dbefd359b04ebef9e47a0eb359">register_exception_translator</a> (ExceptionTranslator &amp;&amp;translator)</td></tr>
<tr class="separator:a4353c0dbefd359b04ebef9e47a0eb359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa580e4fbed60a69cda35ea099a04e1d1"><td class="memTemplParams" colspan="2">template&lt;typename CppException &gt; </td></tr>
<tr class="memitem:aa580e4fbed60a69cda35ea099a04e1d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1exception.html">exception</a>&lt; CppException &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#aa580e4fbed60a69cda35ea099a04e1d1">register_exception</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1scope.html">scope</a>, const char *<a class="el" href="structpybind11_1_1name.html">name</a>, PyObject *<a class="el" href="structpybind11_1_1base.html">base</a>=PyExc_Exception)</td></tr>
<tr class="separator:aa580e4fbed60a69cda35ea099a04e1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913a30079a57934b1bfda83ba4080da4"><td class="memTemplParams" colspan="2">template&lt;return_value_policy policy = return_value_policy::automatic_reference, typename... Args&gt; </td></tr>
<tr class="memitem:a913a30079a57934b1bfda83ba4080da4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a913a30079a57934b1bfda83ba4080da4">print</a> (Args &amp;&amp;...<a class="el" href="classpybind11_1_1args.html">args</a>)</td></tr>
<tr class="separator:a913a30079a57934b1bfda83ba4080da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd4a52df3fbac712407b5cad8449865"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1function.html">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a2bd4a52df3fbac712407b5cad8449865">get_type_overload</a> (const void *this_ptr, const <a class="el" href="structpybind11_1_1detail_1_1type__info.html">detail::type_info</a> *this_type, const char *<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:a2bd4a52df3fbac712407b5cad8449865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf1986e4cc6b7770ee71b3ce88a1a7c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1bf1986e4cc6b7770ee71b3ce88a1a7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1function.html">function</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a1bf1986e4cc6b7770ee71b3ce88a1a7c">get_overload</a> (const T *this_ptr, const char *<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:a1bf1986e4cc6b7770ee71b3ce88a1a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad75b61738e777489ed1f4a30776268"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acad75b61738e777489ed1f4a30776268"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#acad75b61738e777489ed1f4a30776268">reinterpret_borrow</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> h)</td></tr>
<tr class="separator:acad75b61738e777489ed1f4a30776268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8f2939859acb062ae3c38c8b82b9f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b8f2939859acb062ae3c38c8b82b9f0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a4b8f2939859acb062ae3c38c8b82b9f0">reinterpret_steal</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> h)</td></tr>
<tr class="separator:a4b8f2939859acb062ae3c38c8b82b9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de041115880fe435885b9a9d7c2c276"><td class="memTemplParams" colspan="2">template&lt;typename T , detail::enable_if_t&lt; std::is_base_of&lt; object, T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga2de041115880fe435885b9a9d7c2c276"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#ga2de041115880fe435885b9a9d7c2c276">isinstance</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj)</td></tr>
<tr class="separator:ga2de041115880fe435885b9a9d7c2c276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7beb48e900be6e4e45b90482defde822"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7beb48e900be6e4e45b90482defde822"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a7beb48e900be6e4e45b90482defde822">isinstance&lt; handle &gt;</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj)=delete</td></tr>
<tr class="separator:a7beb48e900be6e4e45b90482defde822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc42dbf138ab0de23a58c7952cb8ba9a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:adc42dbf138ab0de23a58c7952cb8ba9a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#adc42dbf138ab0de23a58c7952cb8ba9a">isinstance&lt; object &gt;</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj)</td></tr>
<tr class="separator:adc42dbf138ab0de23a58c7952cb8ba9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga514d6552530d0b02362a2045f43fcdba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#ga514d6552530d0b02362a2045f43fcdba">isinstance</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> type)</td></tr>
<tr class="separator:ga514d6552530d0b02362a2045f43fcdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87cc23c83cdeaec183f0a0e4122d9997"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#ga87cc23c83cdeaec183f0a0e4122d9997">hasattr</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:ga87cc23c83cdeaec183f0a0e4122d9997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef7ee96307a4732fad5df956b387f8a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#gaef7ee96307a4732fad5df956b387f8a8">hasattr</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, const char *<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:gaef7ee96307a4732fad5df956b387f8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0854324102907dc2d82ac413b6e6b66e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#ga0854324102907dc2d82ac413b6e6b66e">getattr</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:ga0854324102907dc2d82ac413b6e6b66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac80ddad26eb3426c93277ce8d7c0f982"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#gac80ddad26eb3426c93277ce8d7c0f982">getattr</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, const char *<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:gac80ddad26eb3426c93277ce8d7c0f982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga715c20d77757165563f28474dc39e80c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#ga715c20d77757165563f28474dc39e80c">getattr</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1name.html">name</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> default_)</td></tr>
<tr class="separator:ga715c20d77757165563f28474dc39e80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a207d73efa28381746217b7afba118f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#ga7a207d73efa28381746217b7afba118f">getattr</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, const char *<a class="el" href="structpybind11_1_1name.html">name</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> default_)</td></tr>
<tr class="separator:ga7a207d73efa28381746217b7afba118f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d54ac3f3614c110d2ffa5c061ee905"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#gad3d54ac3f3614c110d2ffa5c061ee905">setattr</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1name.html">name</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> value)</td></tr>
<tr class="separator:gad3d54ac3f3614c110d2ffa5c061ee905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac63dcad9209e4abd96a430bef04414ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#gac63dcad9209e4abd96a430bef04414ce">setattr</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, const char *<a class="el" href="structpybind11_1_1name.html">name</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> value)</td></tr>
<tr class="separator:gac63dcad9209e4abd96a430bef04414ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64ce16d2a0ab3f9e80fdde0e0857224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1str.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11_1_1literals.html#ac64ce16d2a0ab3f9e80fdde0e0857224">operator&quot;&quot;_s</a> (const char *s, <a class="el" href="namespacepybind11.html#a74292751b6fc8fe14d7c6772ae2fd0fc">size_t</a> size)</td></tr>
<tr class="separator:ac64ce16d2a0ab3f9e80fdde0e0857224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga443ea89aee29c1a3b9d57324d4d089b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepybind11.html#a74292751b6fc8fe14d7c6772ae2fd0fc">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#ga443ea89aee29c1a3b9d57324d4d089b6">len</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> h)</td></tr>
<tr class="separator:ga443ea89aee29c1a3b9d57324d4d089b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03802ec7d35cdd35a26c59cd53db480"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1str.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#gad03802ec7d35cdd35a26c59cd53db480">repr</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> h)</td></tr>
<tr class="separator:gad03802ec7d35cdd35a26c59cd53db480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4e8cc0cdd5b04fd00f4ba1f2d0f5b8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#gab4e8cc0cdd5b04fd00f4ba1f2d0f5b8d">iter</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj)</td></tr>
<tr class="separator:gab4e8cc0cdd5b04fd00f4ba1f2d0f5b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3375b1b2135f6344f5550b7869c5fa64"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a3375b1b2135f6344f5550b7869c5fa64">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classpybind11_1_1handle.html">handle</a> &amp;obj)</td></tr>
<tr class="separator:a3375b1b2135f6344f5550b7869c5fa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104810fb64b2c424c5fb70d6c64f503f"><td class="memTemplParams" colspan="2">template&lt;typename Vector , typename holder_type  = std::unique_ptr&lt;Vector&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:a104810fb64b2c424c5fb70d6c64f503f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1class__.html">class_</a>&lt; Vector, holder_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a104810fb64b2c424c5fb70d6c64f503f">bind_vector</a> (<a class="el" href="classpybind11_1_1module.html">module</a> &amp;m, std::string const &amp;<a class="el" href="structpybind11_1_1name.html">name</a>, Args &amp;&amp;... <a class="el" href="classpybind11_1_1args.html">args</a>)</td></tr>
<tr class="separator:a104810fb64b2c424c5fb70d6c64f503f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0dfb2c0a7f951897b6d1ff9992f34a"><td class="memTemplParams" colspan="2">template&lt;typename Map , typename holder_type  = std::unique_ptr&lt;Map&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:a3b0dfb2c0a7f951897b6d1ff9992f34a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1class__.html">class_</a>&lt; Map, holder_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a3b0dfb2c0a7f951897b6d1ff9992f34a">bind_map</a> (<a class="el" href="classpybind11_1_1module.html">module</a> &amp;m, const std::string &amp;<a class="el" href="structpybind11_1_1name.html">name</a>, Args &amp;&amp;... <a class="el" href="classpybind11_1_1args.html">args</a>)</td></tr>
<tr class="separator:a3b0dfb2c0a7f951897b6d1ff9992f34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659dbbd826463f080f2ce7119986711a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a659dbbd826463f080f2ce7119986711a">get_include</a> (*<a class="el" href="classpybind11_1_1args.html">args</a>, **<a class="el" href="classpybind11_1_1kwargs.html">kwargs</a>)</td></tr>
<tr class="separator:a659dbbd826463f080f2ce7119986711a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description détaillée</h2>
<div class="textblock"><p>glibc defines I as a macro which breaks things, e.g., boost template names </p>
</div><h2 class="groupheader">Documentation des définitions de type</h2>
<a id="aa14f653ec1b63f58b3013ef9d6ac9422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14f653ec1b63f58b3013ef9d6ac9422">&#9670;&nbsp;</a></span>arg_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepybind11.html#aa14f653ec1b63f58b3013ef9d6ac9422">pybind11::arg_t</a> = typedef <a class="el" href="structpybind11_1_1arg__v.html">arg_v</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for backward compatibility &ndash; to be removed in version 2.0. </p>

</div>
</div>
<a id="a6f353deb5dca5ef06dd63358f9a9bb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f353deb5dca5ef06dd63358f9a9bb20">&#9670;&nbsp;</a></span>EigenDMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepybind11.html#a6f353deb5dca5ef06dd63358f9a9bb20">pybind11::EigenDMap</a> = typedef Eigen::Map&lt;MatrixType, 0, <a class="el" href="namespacepybind11.html#a9c1dc06329bd734b9632f108e2006e25">EigenDStride</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23484f7bb5fa23363d338c66c71dc6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23484f7bb5fa23363d338c66c71dc6a8">&#9670;&nbsp;</a></span>EigenDRef</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepybind11.html#a23484f7bb5fa23363d338c66c71dc6a8">pybind11::EigenDRef</a> = typedef Eigen::Ref&lt;MatrixType, 0, <a class="el" href="namespacepybind11.html#a9c1dc06329bd734b9632f108e2006e25">EigenDStride</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c1dc06329bd734b9632f108e2006e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1dc06329bd734b9632f108e2006e25">&#9670;&nbsp;</a></span>EigenDStride</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepybind11.html#a9c1dc06329bd734b9632f108e2006e25">pybind11::EigenDStride</a> = typedef Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74292751b6fc8fe14d7c6772ae2fd0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74292751b6fc8fe14d7c6772ae2fd0fc">&#9670;&nbsp;</a></span>size_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepybind11.html#a74292751b6fc8fe14d7c6772ae2fd0fc">pybind11::size_t</a> = typedef std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51e3d317b399f8925c3b9f1980018481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e3d317b399f8925c3b9f1980018481">&#9670;&nbsp;</a></span>ssize_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepybind11.html#a51e3d317b399f8925c3b9f1980018481">pybind11::ssize_t</a> = typedef Py_ssize_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Documentation du type de l'énumération</h2>
<a id="a08a5898f9a083026531bc5d435f715ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a5898f9a083026531bc5d435f715ea">&#9670;&nbsp;</a></span>eval_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715ea">pybind11::eval_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Valeurs énumérées</th></tr><tr><td class="fieldname"><a id="a08a5898f9a083026531bc5d435f715eaa86e05cca1e5516b3ff4014f9af34aaff"></a>eval_expr&#160;</td><td class="fielddoc"><p>Evaluate a string containing an isolated expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08a5898f9a083026531bc5d435f715eaa9cf39a293befe652b5046b1e7cf9fe58"></a>eval_single_statement&#160;</td><td class="fielddoc"><p>Evaluate a string containing a single statement. Returns <code>none</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08a5898f9a083026531bc5d435f715eaa22b140993f208620cf25bba6e0d5590b"></a>eval_statements&#160;</td><td class="fielddoc"><p>Evaluate a string containing a sequence of statement. Returns <code>none</code>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a5f83e7a05cee9068927633ac47dbe69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f83e7a05cee9068927633ac47dbe69c">&#9670;&nbsp;</a></span>return_value_policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">pybind11::return_value_policy</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approach used to cast a previously unknown C++ instance into a Python object. </p>
<table class="fieldtable">
<tr><th colspan="2">Valeurs énumérées</th></tr><tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69ca2bd9c0ed00116be1258e0cc66617d7c8"></a>automatic&#160;</td><td class="fielddoc"><p>This is the default return value policy, which falls back to the policy <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca5dc4bb19391b04351f49572019c628c0">return_value_policy::take_ownership</a> when the return value is a pointer. Otherwise, it uses return_value::move or return_value::copy for rvalue and lvalue references, respectively. See below for a description of what all of these different policies do. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69ca1c1628c22d69b3b9bac4b5c3674852e3"></a>automatic_reference&#160;</td><td class="fielddoc"><p>As above, but use policy <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69cab8af13ea9c8fe890c9979a1fa8dbde22">return_value_policy::reference</a> when the return value is a pointer. This is the default conversion policy for function arguments when calling Python functions manually from C++ code (i.e. via handle::operator()). You probably won't need to use this. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69ca5dc4bb19391b04351f49572019c628c0"></a>take_ownership&#160;</td><td class="fielddoc"><p>Reference an existing object (i.e. do not create a new copy) and take ownership. Python will call the destructor and delete operator when the object’s reference count reaches zero. Undefined behavior ensues when the C++ side does the same.. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69ca12cba3ee81cf4a793796a51b6327c678"></a>copy&#160;</td><td class="fielddoc"><p>Create a new copy of the returned object, which will be owned by Python. This policy is comparably safe because the lifetimes of the two instances are decoupled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69ca3734a903022249b3010be1897042568e"></a>move&#160;</td><td class="fielddoc"><p>Use std::move to move the return value contents into a new instance that will be owned by Python. This policy is comparably safe because the lifetimes of the two instances (move source and destination) are decoupled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69cab8af13ea9c8fe890c9979a1fa8dbde22"></a>reference&#160;</td><td class="fielddoc"><p>Reference an existing object, but do not take ownership. The C++ side is responsible for managing the object’s lifetime and deallocating it when it is no longer used. Warning: undefined behavior will ensue when the C++ side deletes an object that is still referenced and used by Python. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69caa39bc0596cb125c1605a78fbd287df7f"></a>reference_internal&#160;</td><td class="fielddoc"><p>This policy only applies to methods and properties. It references the object without taking ownership similar to the above <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69cab8af13ea9c8fe890c9979a1fa8dbde22">return_value_policy::reference</a> policy. In contrast to that policy, the function or property’s implicit this argument (called the parent) is considered to be the the owner of the return value (the child). <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a> then couples the lifetime of the parent to the child via a reference relationship that ensures that the parent cannot be garbage collected while Python is still using the child. More advanced variations of this scheme are also possible using combinations of <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69cab8af13ea9c8fe890c9979a1fa8dbde22">return_value_policy::reference</a> and the <a class="el" href="structpybind11_1_1keep__alive.html" title="Keep patient alive while nurse lives.">keep_alive</a> call policy </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Documentation des fonctions</h2>
<a id="a43f875b57085d18e33b68e3c666facf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f875b57085d18e33b68e3c666facf8">&#9670;&nbsp;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pybind11::__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(noinline)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the shared data that can be later recovered by <code>get_shared_data()</code>. </p>
<p>Used internally.</p>
<p>Returns a named pointer that is shared among all extension modules (using the same <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a> version) running in the current interpreter. Names starting with underscores are reserved for internal usage. Returns <code>nullptr</code> if no matching entry was found. </p>

</div>
</div>
<a id="a3b0dfb2c0a7f951897b6d1ff9992f34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0dfb2c0a7f951897b6d1ff9992f34a">&#9670;&nbsp;</a></span>bind_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Map , typename holder_type  = std::unique_ptr&lt;Map&gt;, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1class__.html">class_</a>&lt;Map, holder_type&gt; pybind11::bind_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1module.html">module</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a104810fb64b2c424c5fb70d6c64f503f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104810fb64b2c424c5fb70d6c64f503f">&#9670;&nbsp;</a></span>bind_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector , typename holder_type  = std::unique_ptr&lt;Vector&gt;, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1class__.html">class_</a>&lt;Vector, holder_type&gt; pybind11::bind_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1module.html">module</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade1f8946c805279f41d7f6eed0d4f07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1f8946c805279f41d7f6eed0d4f07d">&#9670;&nbsp;</a></span>cast() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , detail::enable_if_t&lt;!detail::is_pyobject&lt; T &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pybind11::cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpybind11_1_1handle.html">handle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87f21f6281dddbba982c721e93d1f60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f21f6281dddbba982c721e93d1f60e">&#9670;&nbsp;</a></span>cast() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , detail::enable_if_t&lt;!detail::is_pyobject&lt; T &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1object.html">object</a> pybind11::cast </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca1c1628c22d69b3b9bac4b5c3674852e3">return_value_policy::automatic_reference</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1handle.html">handle</a>&#160;</td>
          <td class="paramname"><em>parent</em> = <code><a class="el" href="classpybind11_1_1handle.html">handle</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb9d391ba89e4dbc85bc088c637a454b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9d391ba89e4dbc85bc088c637a454b">&#9670;&nbsp;</a></span>cast() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepybind11_1_1detail.html#a492fb1fcf079a5bc67248b852bc73619">detail::enable_if_t</a>&lt;<a class="el" href="structpybind11_1_1detail_1_1move__always.html">detail::move_always</a>&lt;T&gt;::value, T&gt; pybind11::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1object.html">object</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37c29751349cfc3a1b5e8b4765c23e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c29751349cfc3a1b5e8b4765c23e55">&#9670;&nbsp;</a></span>cast() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepybind11_1_1detail.html#a492fb1fcf079a5bc67248b852bc73619">detail::enable_if_t</a>&lt;<a class="el" href="structpybind11_1_1detail_1_1move__if__unreferenced.html">detail::move_if_unreferenced</a>&lt;T&gt;::value, T&gt; pybind11::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1object.html">object</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23d1d141b22c8733a7212bc74d89cbf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d1d141b22c8733a7212bc74d89cbf8">&#9670;&nbsp;</a></span>cast() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepybind11_1_1detail.html#a492fb1fcf079a5bc67248b852bc73619">detail::enable_if_t</a>&lt;<a class="el" href="namespacepybind11_1_1detail.html#a9b95d0bea18a9cb7599182d1f32a7f6a">detail::move_never</a>&lt;T&gt;::value, T&gt; pybind11::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1object.html">object</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56b1a96dad971e6c0edd9b796cc57880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b1a96dad971e6c0edd9b796cc57880">&#9670;&nbsp;</a></span>eval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;eval_mode mode = eval_expr, size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1object.html">object</a> pybind11::eval </td>
          <td>(</td>
          <td class="paramtype">const char(&amp;)&#160;</td>
          <td class="paramname"><em>s</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td>
          <td class="paramname"><em>global</em> = <code><a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td>
          <td class="paramname"><em>local</em> = <code><a class="el" href="classpybind11_1_1object.html">object</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae26f489829ee95049a3cbf473d3c50bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26f489829ee95049a3cbf473d3c50bc">&#9670;&nbsp;</a></span>eval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;eval_mode mode = eval_expr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1object.html">object</a> pybind11::eval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1str.html">str</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td>
          <td class="paramname"><em>global</em> = <code><a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td>
          <td class="paramname"><em>local</em> = <code><a class="el" href="classpybind11_1_1object.html">object</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3958ed51fe6e4bf962b04e32d01c242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3958ed51fe6e4bf962b04e32d01c242">&#9670;&nbsp;</a></span>eval_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;eval_mode mode = eval_statements&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1object.html">object</a> pybind11::eval_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1str.html">str</a>&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td>
          <td class="paramname"><em>global</em> = <code><a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td>
          <td class="paramname"><em>local</em> = <code><a class="el" href="classpybind11_1_1object.html">object</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae38838be20e46edfdb3dbc03f176d7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38838be20e46edfdb3dbc03f176d7bc">&#9670;&nbsp;</a></span>exec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pybind11::exec </td>
          <td>(</td>
          <td class="paramtype">const char(&amp;)&#160;</td>
          <td class="paramname"><em>s</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td>
          <td class="paramname"><em>global</em> = <code><a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td>
          <td class="paramname"><em>local</em> = <code><a class="el" href="classpybind11_1_1object.html">object</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3ca1928aef1b51fa07d8720ce75fdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ca1928aef1b51fa07d8720ce75fdf7">&#9670;&nbsp;</a></span>exec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pybind11::exec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1str.html">str</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td>
          <td class="paramname"><em>global</em> = <code><a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td>
          <td class="paramname"><em>local</em> = <code><a class="el" href="classpybind11_1_1object.html">object</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f49a19c03be57ee8ff8427a5f30dc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f49a19c03be57ee8ff8427a5f30dc20">&#9670;&nbsp;</a></span>finalize_interpreter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pybind11::finalize_interpreter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\rst Shut down the Python interpreter. No <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a> or CPython API functions can be called after this. In addition, <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a> objects must not outlive the interpreter:</p>
<p>.. code-block:: cpp </p><pre class="fragment">{ // BAD
    py::initialize_interpreter();
    auto hello = py::str("Hello, World!");
    py::finalize_interpreter();
} // &lt;-- BOOM, hello's destructor is called after interpreter shutdown

{ // GOOD
    py::initialize_interpreter();
    { // scoped
        auto hello = py::str("Hello, World!");
    } // &lt;-- OK, hello is cleaned up properly
    py::finalize_interpreter();
}

{ // BETTER
    py::scoped_interpreter guard{};
    auto hello = py::str("Hello, World!");
}
</pre><p> .. warning:: </p><pre class="fragment">The interpreter can be restarted by calling `initialize_interpreter` again.
Modules created using pybind11 can be safely re-initialized. However, Python
itself cannot completely unload binary extension modules and there are several
caveats with regard to interpreter restarting. All the details can be found
in the CPython documentation. In short, not all interpreter memory may be
freed, either due to reference cycles or user-created global data.
</pre><p> \endrst </p>

</div>
</div>
<a id="a659dbbd826463f080f2ce7119986711a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659dbbd826463f080f2ce7119986711a">&#9670;&nbsp;</a></span>get_include()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pybind11.get_include </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa297ec4bf4b85dc134d56708fbfcc850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa297ec4bf4b85dc134d56708fbfcc850">&#9670;&nbsp;</a></span>get_or_create_shared_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; pybind11::get_or_create_shared_data </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a typed reference to a shared data entry (by using <code>get_shared_data()</code>) if such entry exists. Otherwise, a new object of default-constructible type <code>T</code> is added to the shared data under the given name and a reference to it is returned. </p>

</div>
</div>
<a id="a1bf1986e4cc6b7770ee71b3ce88a1a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf1986e4cc6b7770ee71b3ce88a1a7c">&#9670;&nbsp;</a></span>get_overload()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1function.html">function</a> pybind11::get_overload </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>this_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bd4a52df3fbac712407b5cad8449865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd4a52df3fbac712407b5cad8449865">&#9670;&nbsp;</a></span>get_type_overload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1function.html">function</a> pybind11::get_type_overload </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>this_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpybind11_1_1detail_1_1type__info.html">detail::type_info</a> *&#160;</td>
          <td class="paramname"><em>this_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3d4074b855542774c3fbdd75697d48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d4074b855542774c3fbdd75697d48c">&#9670;&nbsp;</a></span>implicitly_convertible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputType , typename OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pybind11::implicitly_convertible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67231190432080a41b98fd771c5d3dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67231190432080a41b98fd771c5d3dff">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpybind11_1_1detail_1_1init.html">detail::init</a>&lt;Args...&gt; pybind11::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92d1d3fd106f97b8e8fbc0047c8b924f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d1d3fd106f97b8e8fbc0047c8b924f">&#9670;&nbsp;</a></span>init_alias()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpybind11_1_1detail_1_1init__alias.html">detail::init_alias</a>&lt;Args...&gt; pybind11::init_alias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a37202a545a53e60d9722b5712b9171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a37202a545a53e60d9722b5712b9171">&#9670;&nbsp;</a></span>initialize_interpreter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pybind11::initialize_interpreter </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init_signal_handlers</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\rst Initialize the Python interpreter. No other <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a> or CPython API functions can be called before this is done; with the exception of <code>PYBIND11_EMBEDDED_MODULE</code>. The optional parameter can be used to skip the registration of signal handlers (see the Python documentation for details). Calling this function again after the interpreter has already been initialized is a fatal error. \endrst </p>

</div>
</div>
<a id="a7beb48e900be6e4e45b90482defde822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7beb48e900be6e4e45b90482defde822">&#9670;&nbsp;</a></span>isinstance&lt; handle &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__python__builtins.html#ga2de041115880fe435885b9a9d7c2c276">pybind11::isinstance</a>&lt; <a class="el" href="classpybind11_1_1handle.html">handle</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1handle.html">handle</a>&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adc42dbf138ab0de23a58c7952cb8ba9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc42dbf138ab0de23a58c7952cb8ba9a">&#9670;&nbsp;</a></span>isinstance&lt; object &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__python__builtins.html#ga2de041115880fe435885b9a9d7c2c276">pybind11::isinstance</a>&lt; <a class="el" href="classpybind11_1_1object.html">object</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1handle.html">handle</a>&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac97330a2a87d0653768770751b057c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97330a2a87d0653768770751b057c5e">&#9670;&nbsp;</a></span>make_iterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename ValueType  = decltype(*std::declval&lt;Iterator&gt;()), typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1iterator.html">iterator</a> pybind11::make_iterator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a python iterator from a first and past-the-end C++ InputIterator. </p>

</div>
</div>
<a id="abc7e251f8927c3f839ec9beff8662a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7e251f8927c3f839ec9beff8662a4c">&#9670;&nbsp;</a></span>make_iterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1iterator.html">iterator</a> pybind11::make_iterator </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an iterator over values of an stl container or other container supporting <code>std::begin()</code>/<code>std::end()</code> </p>

</div>
</div>
<a id="a9720b33862b4fbd9345c2bf2a0e407f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9720b33862b4fbd9345c2bf2a0e407f7">&#9670;&nbsp;</a></span>make_key_iterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename KeyType  = decltype((*std::declval&lt;Iterator&gt;()).first), typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1iterator.html">iterator</a> pybind11::make_key_iterator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an python iterator over the keys (<code>.first</code>) of a iterator over pairs from a first and past-the-end InputIterator. </p>

</div>
</div>
<a id="a451a8f82d09d763f5400dead333116ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451a8f82d09d763f5400dead333116ee">&#9670;&nbsp;</a></span>make_key_iterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1iterator.html">iterator</a> pybind11::make_key_iterator </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an iterator over the keys (<code>.first</code>) of a stl map-like container supporting <code>std::begin()</code>/<code>std::end()</code> </p>

</div>
</div>
<a id="a829aea796e8a24212b310db43534c1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829aea796e8a24212b310db43534c1b7">&#9670;&nbsp;</a></span>make_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;return_value_policy policy = return_value_policy::automatic_reference, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1tuple.html">tuple</a> pybind11::make_tuple </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a80923cbfeaa7668191f479b40a94957e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80923cbfeaa7668191f479b40a94957e">&#9670;&nbsp;</a></span>method_adaptor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pybind11::method_adaptor </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; decltype(std::forward&lt;F&gt;(f)) </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a pointer to a member function, cast it to its <code>Derived</code> version. Forward everything else unchanged. </p>

</div>
</div>
<a id="aeb36fd4bbf6d949769e083dc9bdf7426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb36fd4bbf6d949769e083dc9bdf7426">&#9670;&nbsp;</a></span>method_adaptor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename Return , typename Class , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pybind11::method_adaptor </td>
          <td>(</td>
          <td class="paramtype">Return(Class::*)(Args...)&#160;</td>
          <td class="paramname"><em>pmf</em></td><td>)</td>
          <td> -&gt; Return (Derived::*)(Args...) </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cadb7f665dad17868aa4cd045f3b017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cadb7f665dad17868aa4cd045f3b017">&#9670;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepybind11_1_1detail.html#a492fb1fcf079a5bc67248b852bc73619">detail::enable_if_t</a>&lt;!<a class="el" href="namespacepybind11_1_1detail.html#a9b95d0bea18a9cb7599182d1f32a7f6a">detail::move_never</a>&lt;T&gt;::value, T&gt; pybind11::move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1object.html">object</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3375b1b2135f6344f5550b7869c5fa64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3375b1b2135f6344f5550b7869c5fa64">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pybind11::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpybind11_1_1handle.html">handle</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a913a30079a57934b1bfda83ba4080da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913a30079a57934b1bfda83ba4080da4">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;return_value_policy policy = return_value_policy::automatic_reference, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pybind11::print </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa580e4fbed60a69cda35ea099a04e1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa580e4fbed60a69cda35ea099a04e1d1">&#9670;&nbsp;</a></span>register_exception()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CppException &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1exception.html">exception</a>&lt;CppException&gt;&amp; pybind11::register_exception </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1handle.html">handle</a>&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>base</em> = <code>PyExc_Exception</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a Python exception in <code>m</code> of the given <code>name</code> and installs an exception translator to translate the C++ exception to the created Python exception using the exceptions what() method. This is intended for simple exception translations; for more complex translation, register the exception object and translator directly. </p>

</div>
</div>
<a id="a4353c0dbefd359b04ebef9e47a0eb359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4353c0dbefd359b04ebef9e47a0eb359">&#9670;&nbsp;</a></span>register_exception_translator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExceptionTranslator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pybind11::register_exception_translator </td>
          <td>(</td>
          <td class="paramtype">ExceptionTranslator &amp;&amp;&#160;</td>
          <td class="paramname"><em>translator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acad75b61738e777489ed1f4a30776268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad75b61738e777489ed1f4a30776268">&#9670;&nbsp;</a></span>reinterpret_borrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pybind11::reinterpret_borrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1handle.html">handle</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\rst Declare that a <code>handle</code> or <code>PyObject *</code> is a certain type and borrow the reference. The target type <code>T</code> must be <code>object</code> or one of its derived classes. The function doesn't do any conversions or checks. It's up to the user to make sure that the target type is correct.</p>
<p>.. code-block:: cpp </p><pre class="fragment">PyObject *p = PyList_GetItem(obj, index);
py::object o = reinterpret_borrow&lt;py::object&gt;(p);
</pre><p> or py::tuple t = reinterpret_borrow&lt;py::tuple&gt;(p); // &lt;&ndash; <code>p</code> must be already be a <code>tuple</code> \endrst </p>

</div>
</div>
<a id="a4b8f2939859acb062ae3c38c8b82b9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8f2939859acb062ae3c38c8b82b9f0">&#9670;&nbsp;</a></span>reinterpret_steal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pybind11::reinterpret_steal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1handle.html">handle</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\rst Like <code>reinterpret_borrow</code>, but steals the reference.</p>
<p>.. code-block:: cpp</p>
<p>PyObject *p = PyObject_Str(obj); py::str s = reinterpret_steal&lt;py::str&gt;(p); // &lt;&ndash; <code>p</code> must be already be a <code>str</code> \endrst </p>

</div>
</div>
<a id="a5a9b99aeffa23dc8596bc5ab46bdec99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9b99aeffa23dc8596bc5ab46bdec99">&#9670;&nbsp;</a></span>vectorize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename FuncType  = typename detail::remove_class&lt;decltype(&amp;detail::remove_reference_t&lt;Func&gt;::operator())&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pybind11::vectorize </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; decltype(
        <a class="el" href="namespacepybind11_1_1detail.html#a25c49715d64fc799eef5cfa04f20d119">detail::vectorize_extractor</a>(std::forward&lt;Func&gt;(f), (FuncType *) nullptr)) </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ccb3d918a6c83f0ed93b7aae5e3dd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccb3d918a6c83f0ed93b7aae5e3dd77">&#9670;&nbsp;</a></span>vectorize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpybind11_1_1detail_1_1vectorize__helper.html">detail::vectorize_helper</a>&lt;Return (*)(Args...), Return, Args...&gt; pybind11::vectorize </td>
          <td>(</td>
          <td class="paramtype">Return(*)(Args ...)&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cb3c0b9044e0b0d3e8fc0324f485acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb3c0b9044e0b0d3e8fc0324f485acf">&#9670;&nbsp;</a></span>vectorize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return , typename Class , typename... Args, typename Helper  = detail::vectorize_helper&lt;decltype(std::mem_fn(std::declval&lt;Return (Class::*)(Args...)&gt;())), Return, Class *, Args...&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Helper pybind11::vectorize </td>
          <td>(</td>
          <td class="paramtype">Return(Class::*)(Args...)&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré par&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
